#Electric power system model
###Общие данные для всего проекта
Это простая модель выделенной электроэнергетической системы, состоящая из собственно модели и диспетчера. В модели моделируется работа оборудования электрической станции, участвующего в процессе поддержания частоты в энергосистеме и два вида потребителей нагрузки. Модель получает суточные графики генерации от диспетчера. Диспетчер расчитывает (на данный момент выдаёт заглушку) суточные графики генерации для электростанций в системе и получает от электростанций и потребителей мгновенные значения вырабатываемой и потребляемой мощности через заданные промежутки времени в модели. Приложение состоит из четырех пакетов [epsm-core](https://github.com/epsm/epsm-core), [epsm-web](https://github.com/epsm/epsm-web), [epsd-core](https://github.com/epsm/epsd-core) и [epsd-web](https://github.com/epsm/epsd-web). К каждому пакету прилагается описание. Приложение запущенно на двух серверах ([модель](http://model-epsm.rhcloud.com/) и [диспетчер](http://dispatcher-epsm.rhcloud.com/app/history)) взаимодействующих между собой с помощью обмена сообщениями в формате JSON и имеющих web-интерфейсы.

##epsm-core
#### описание предметной области

Частота в энергосистеме служит показателем соответствия генерации и потребления в текущий момент времени. Чтобы поддерживать частоту постоянной, необходимо сохранять баланс мощностей генерации и потребления.

Выделяют три вида регулирования частоты:

1. первичное регулирование, осуществляемое всеми энергоблоками в пределах имеющихся в данный момент времени резервов первичного регулирования.
2. Вторичное регулирование частоты. Первичное регулирование частоты, обладающее определенным статизмом, принципиально не может обеспечить постоянного значения частоты в энергосистеме при отклонениях нагрузки. Восстановление ее заданного значения беспечивает вторичное регулирование частоты с помощью выделенных для этого генераторов.
3. Третичное регулирование (не моделируется).

Частота в сети поддерживается регуляторами частоты вращения турбин. Характеристика регулятора в установившемся режиме представляет
зависимость нагрузки от частоты. Регулятор можно настроить на астатическую и статическую характеристику. В первом случае регулятор поддерживает постоянную частоту вращения агрегата независимо от нагрузки, во втором случае нагрузка зависит от частоты вращения. С увеличением частоты вращения агрегата нагрузка уменьшается и наоборот.

При параллельной работе агрегатов распределение нагрузки происходит обратно пропорционально статизму характеристики регулирования. Если хотя бы один из агрегатов системы имеет астатическую характеристику, характеристика всей энергосистемы будет также астатической. В этом случае (при любых изменениях нагрузки) частота в энергосистеме меняться не будет, а агрегаты, имеющие статические характеристики, будут работать с постоянной нагрузкой. Все изменения нагрузки воспримет на себя агрегат с астатической характеристикой регулирования.

При изменении частоты у большинства потребителей меняется их производительность. Все потребители разделяются на две группы: 

1. мощность не зависит от частоты;
2. мощность зависит от степени частоты Р=Рном(Fтек/Fном)^x.

Здесь моделируются потребители двух видов:

1. мощность которых задаётся суточным графиком потребления и процентом случайного отклонения от этого графика.
2. случайно включающиеся на заданный промежуток времени и с заданной мощностью.

#### особености реализации
Здесь будут приведенны диаграммы классов c достаточной для понимания работы программы детализацией и дано описание работы программы.

+ диаграмма классов управления моделью
![simulation class diagramm](https://cloud.githubusercontent.com/assets/16285736/12733499/e2c67916-c943-11e5-8978-c8f4e34a8a89.jpg)

+ диаграмма классов для иерархии PowerObject
![powerobject class diagram](https://cloud.githubusercontent.com/assets/16285736/12742632/2b6ec9e2-c990-11e5-809a-b8ca87e10bc7.jpg)
интерфейс Dispatcher см. раздел особенности реализации пакета [epsd-core](https://github.com/epsm/epsd-core).

+ диаграмма классов для иерархии Message
![message class diagram](https://cloud.githubusercontent.com/assets/16285736/12732296/8d1cedac-c93d-11e5-93cc-159af9055fad.jpg)

В модели на данный момент есть три вида объектов:

1. PowerStation - электростанция, содержит один и более генераторов.
2. ScheduledLoadConsumer - потребитель, нагрузка которого задаётся суточным графиком (в реальности графики для будних/выходных/праздничных дней отличаются) и процентом отклонения от этого графика.
3. ShockLoadConsumer - потребитель, который включается на заданное время, с заданной мощностью и выключается на заданное время. Время включения, бездействия и нагрузка принимают случайное значение от половины до полного значения заданного параметра.

Все объекты реализуют интерфейс SimulationObject. Объект ElectricPowerSystemSimulation используя метод calculatePowerBalance() вышеназванного интерфейса запрашивает текущий баланс мощности. Он положительный для электростанций и отрицательный для потребителей. Также выполняя это метод объекты производят вычисления своего внутреннего состояния, например настраивается мощность генераторов электростанции и создают объект State, отражающий их текущее состояние. Через метод executeCommand(...) объекты получают команды диспетчера. На данный момент реализованно только получения суточного графика генерации для электростанции. Выполняя метод doRealTimeOperation() интерфейса RealTimeOperation объекты отправляют накопившиеся объекты State диспетчеру с помощью объекта PowerObjectMessageManager. Принмая и отправляя объекты PowerObjectMessageManager проверяет их соответствие данному подклассу класса PowerObject. Валидация принимаемых команд реализована в подклассах класса PowerObject с помощью объектов, являющимися экземплярами классов, унаследованных от абстрактного класса CommandValidator. 

Моделирование процесса потребления и генерации электроэнергии происходит дискретно, с заданным шагом. SimulationRunner через заданный промежеток времени вызывает метод calculateNextStep() объекта,  ElectricPowerSystemSimulation, который в свою очередь вызывает метод calculatePowerBalance() для каждого объекта в симуляции. Время в симуляции не связанно с реальным и расчитывается добавлением заданной величины к предыдущей на каждом шаге. Также SimulationRunner вторым потоком вызывает метод doRealTimeOperation() для каждого объекта в симуляции. Объекты PowerObject в вышеописанной ситуации потокобезопастны, что достигается присваиванием ссылки на объект State в нити, выполняющей метод calculatePowerBalance() только после его полного заполения, т.е. нить выполняющая doRealTimeOperation() только получает ссылку на последний заполненный к этому моменту объект.

Взаимодействие между диспетчером и объектами из модели происходит посредством экземпляров классов, унаследованных от абстрактного класса Message.

Более подробно о диспетчере см. [epsd-core](https://github.com/epsm/epsd-core).

На данный момент нельзя добавлять объекты в модель. Точнее нельзя добавить объекты с желаемыми параметрами так как фабрики объектов реализованы в виде заглушек, создающих объекты с предопределенными параметрами вместо принимаемых. В результате модель создаётся с заранее сконфигурированным набором объекотв.

epsm-core используется как модель для пакета [epsm-web](https://github.com/epsm/epsm-web), который является веб-приложением. epsm-web взаимодействует с помощью JSON с [epsd-web](https://github.com/epsm/epsd-web) который также является веб-приложением.
epsm-web кроме взаимодействия с диспетчером позволяет [посмотреть](http://model-epsm.rhcloud.com) состояние модели на текущий момент. epsd-web кроме взаимодействия с моделью позволяет [посмотреть](http://dispatcher-epsm.rhcloud.com/app/history) графики частоты, генерации и потребления за прошедшие сутки.

#### технологии
Java core, JSON, SLF4J, Logback, Junit, Mockito, PowerMockito.

Покрытие unit-тестами согласно EclEmma 97,5%.